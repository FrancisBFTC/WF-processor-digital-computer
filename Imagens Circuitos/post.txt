Circuitos sequenciais & combinatórios de armazenamento, leitura e apresentação de dados via temporização.

Fala pessoal, Hello World! Após algum tempo sem escrever postagens, quero apresentar a vocês um circuito lógico digital que estou montando no Proteus e que pode abrir portas para um novo Curso no Youtube - "Construção de Computadores". 

Este circuito utiliza portas lógicas, que podem ser feitas apenas com transístores, no intuito de simular a mecânica interna de microprocessadores & microcontroladores no geral. Desta forma, podemos criar combinações de portas lógicas onde a saída vai depender da entrada (Circuitos Combinatórios), ou até mesmo ter uma saída que reenvia para a entrada formando um loop, onde a saída também depende da própria saída além da entrada (Circuitos Sequenciais), e o objetivo destes circuitos sequenciais é na "memorização de estados".

O fato de um circuito sequencial poder memorizar estados é o que o torna um "Circuito de Memória", pois ele memoriza um estado elétrico num instante anterior. No nosso projeto estamos utilizando este tipo de circuito no contador de programa, nos registradores e na memória de dados/programa. Enquanto que os circuitos combinatórios utilizamos no Full-Adder para somar números no contador e no codificador hexadecimal do display de 7 segmentos.

Nos circuitos sequenciais nós temos 2 tipos: os assíncronos e síncronos. Os assíncronos são aqueles que são "Sensíveis ao nível", ou seja, o nível que estiver na entrada seja ele 0 ou 1 (0V ou 5V), imediatamente é enviado/alterado o dado na saída, enquanto que os síncronos eles são "Sensíveis a borda", onde a borda é a transição de subida/descida do Clock, Ligando/Desligando respectivamente, isto significa que o estado de mudança na saída deste circuito só será afetado durante uma transição do clock, seja ela subida ou descida, e isso vai depender da configuração do circuito.

Quando configuramos um "circuito sequencial assíncrono", estamos criando um circuito de memória com armazenamento imediato, normalmente chamados de "Latch", dentre os tipos de latchs são: 

Latch SR: S vem de "SET" e R vem de "RESET", que é o mesmo de "CLEAR". A função do pino Set é definir o bit da célula para 1 e a função do pino RESET/CLEAR é definir o bit da célula para 0 (Limpar o bit), todos os 2 pinos devem receber o nível lógico alto 1.

Latch JK: O JK é bem parecido com o SR, a diferença é que ele tem 2 portas AND adicionais nas entradas S e R para corrigir um problema do Latch SR, que são as "configurações proibidas", quando as 2 entradas estão ligadas, os 2 pinos se tornam J e K.  

Latch D transparente: Utiliza a mesma configuração do JK, porém transformando o J e K em apenas 1 pino - O pino D. O Pino D pode  ligar ou desligar a célula, apenas se outro pino adicional estiver ativado - O Pino "Enable". O Enable habilita/desabilita as alterações das células pelo pino D.

Latch T: O T utiliza a mesma configuração do JK e também semelhante ao D (Com diferença de não ter uma porta NOT de negação do estado), Com o Latch T você tem +2 pinos adicionais (Além do próprio T) que é o PRESET e CLEAR, que podem selecionar até 2 células, mas isto depende da configuração, pois existem Latchs JK com o PRESET e CLEAR também.

Se você pega todos estes tipos de Latches sem entrada de Clock, e adiciona uma entrada de Clock, você está criando um Latch Sensível a Borda, correto? Então, a partir de agora serão chamados de "Flip-Flop". O Flip-Flop SR, JK, D, e T serão os mesmos que foram citados acima, a diferença é que terão uma entrada de Clock - O armazenamento do dado só será feito ou se o pulso de Clock for ligado ou se o pulso for desligado.

O Contador de Programa que montei (Visto na 1ª imagem), ele tem o tamanho de 3 bits, ou seja, são 3 células Flip-Flop SR (Latch SR Síncrono Sensível a Borda). Cada célula envia para um Full-Adder que vai somar + um número predeterminado, por padrão é o número 1, logo ele vai fazendo uma contagem de 1 em 1 (Caso este número 1 não seja alterado pra outro número, o que pode acontecer) até a capacidade máxima de 3 bits, isto é, de 0 a 7 ou 000b a 111b. A saída do Full-Adder, que é o resultado da soma, trafega tanto para o codificador de display como para as células do registrador R0 (Que já são Latches SR Assíncronos Sensível ao nível). 

Como pode ser visto na 3ª imagem, o formato de armazenamento dos registradores é "paralelo", isto significa que cada entrada ou cada saída será gerenciada de forma independente e imediata. Se fosse armazenamento em série (ou Serial), cada célula teria que deslocar seu estado pra próxima célula até preencher o registrador, sendo um sistema de deslocamento de bits na entrada e na saída.
 
Consequentemente este tipo de sistema, que é o armazenamento serial, é mais lento do que o paralelo.
Por padrão o endereço selecionado pelo controlador de endereços de registros é o endereço 000b ou 0x00, selecionando o R0. O "controlador de endereços" será um multiplexador de 3 entradas e 8 saídas que vai enviar um estado elétrico pra 1 byte específico dependendo da sua entrada binária, a saída elétrica vai ativar o "controlador de acesso" daquele byte através do 1ª pino do multiplexador de acesso, enquanto que o 2ª pino do multiplexador de acesso poderá ter o estado 0 (modo leitura) ou o estado 1 (modo escrita), dependendo do estado, o multiplexador vai ativar as portas AND das entradas de dados ou as portas AND das saídas de dados.
As portas AND da entrada de dados não depende apenas da saída do multiplexador de acesso, depende também das saídas do "Controlador de Dados", que controla o barramento de dados pra determinar se o dado será setado ou zerado, isto é, definido pra 1 ou 0. Neste controlador nós temos um multiplexador 8 entradas e 16 saídas, pra cada byte de memória. Cada uma entrada de um bit for 0, o multiplexador daquele bit envia um nível lógico alto para uma porta AND de CLEAR (Limpar), enquanto que se a entrada de um bit for 1, o multiplexador envia um nível lógico alto para uma porta AND de SET (Definir), o AND que tiver definido como 1, ele pode limpar ou setar uma célula de um dos registros selecionados, caso o acesso seja habilitado com modo escrita, sendo leitura todo este processo é feito para as portas AND de saída. 

Nas portas AND de saída, pelo barramento de dados, vemos no lado direito da 4ª imagem, que se interligam através de uma porta OR, isto significa que nós temos 8 saídas de células de cada registro, conectados em portas OR, logo temos 8 portas OR com 8 pinos cada. O dado de 8 bits do registro selecionado, será realmente considerado pelas saídas das portas OR. O Dado do contador (Saída do Full-Adder) é armazenado no registrador R0 quando o pulso de Clock está ativo (transição de subida) e quando o pulso de Clock está inativo (transição de descida) o controlador de acesso é habilitado como leitura, habilitando a saída do R0 que voltará pro registro Flip-Flop do Contador, quando o bit carry-out do Registro Flip-Flop é ativado, ele automaticamente zera o Registro Flip-Flop do Contador, isto é o que de fato define uma contagem, se aumentarmos o tamanho do registro Flip-Flop (Criar +5 células Latches), nós teríamos um contador contando de 0 a 255.

A Saída do Full-Adder do Contador de Programa também vai para a entrada do Codificador Hexadecimal de Display visto na 2ª imagem. Este codificador é realizado por uma sequência de operações booleanas composto por um circuito combinatório de 47 portas lógicas: sendo 9 portas XOR, 11 portas OR, 23 portas AND, 3 portas NAND e 1 porta NOT, isto é, pra cada dígito hexadecimal nós temos 47 portas lógicas, como temos 2 dígitos hexadecimais no Display, então no total são 94 portas lógicas, sendo 2 circuitos combinatórios, um pra cada nibble (4 bits de saída). As operações booleanas exatas feito em cima das entradas binárias vindo do contador, garante uma saída de estados exatos que vão ligar/desligar leds do Display de 7 segmentos, justamente porque existem 7 leds neste Display: Os LEDs a,b,c,d,e,f,g; Logo a saída binária das operações booleanas são 7 bits.

A saída do contador também é enviada para o "Controlador de Memória de Programa/Dados". Atualmente ela pode ser de qualquer um dos 2 tipos, pois ainda não fiz nada em relação a Unidade de Controle pra decodificar instruções, no entanto, nós temos saídas binárias desta memória de cada byte por vez. Observe-se que na 7ª imagem temos uma Matriz de células Latch, porém a cada 8 células nós temos 1 byte que é controlado pelo multiplexador de endereços, pois existe 1 multiplexador pra cada coluna que por sua vez também controla as linhas, pode ser visto que cada linha de células contem uma porta AND interligada na porta AND do multiplexador de cada coluna. Então nossa matriz de bytes é de 2x8 (2 linhas x 8 colunas), totalizando 16 bytes de memória. Os controladores de barramento de dados, endereço e controle/acesso é feita quase da mesma forma que os "controlador de registros", a diferença é que temos um circuito mais reduzido, contendo um único multiplexador que controla tudo, pois dividimos a memória em uma matriz bidimensional, o que facilita muito. Esta estratégia também pode ser imposta nos registradores.
 
O Contador de Programa neste circuito define o endereço a ser lido da memória RAM, com a configuração de 16 bytes, temos o segmento de 2 bits que vai de 00 a 01 e o offset de 3 bits que vai de 000 a 111, ou seja, o segmento representará a linha e o offset representará a coluna. Com 5 bits no total podemos endereçar até 32 bytes de memória RAM, enquanto que com 8 bits, podemos endereçar até 256 bytes. Na configuração deste circuito atual, a cada vez que o Pulso de Clock é desligado, na transição de descida, os dados da memória estão sendo enviados pra outro lugar, este outro lugar pode ser a unidade de controle que decodificará a instrução binária, já a cada vez que o pulso de Clock é ligado, na transição de subida, algo está sendo escrito enviando-se na direção das memórias, que poderiam ser os registradores R0, R1,R2 e R3 ou até mesmo a próxima memória RAM.  Na 6ª imagem podemos ver os 8 circuitos sequenciais assíncronos sendo 8 células Latch SR, cada célula tendo 3 portas AND, 2 pra entrada e 1 pra saída. As 2 de entrada a primeira é para o CLEAR da célula e a 2ª é para o SET da célula, enquanto que a 3ª porta AND é para saída.
 
As portas AND de entrada tem os pinos "Enable Write" vindo do barramento de acesso, Cn e Sn onde C é Clear, S é Set e n é o número do bit, vindo do barramento de dados e o pino de seleção de endereço, vindo do barramento de endereços (Controlado pelo multiplexador) que se interliga em todas as portas AND de todas as células daquele byte específico. No barramento de saída de dados (vinda das portas AND de saída da célula), nós temos 16 portas OR, cada porta com 8 pinos de entrada e + 8 portas OR cada porta com 4 pinos de entrada: As 16 portas OR representam os 16 bytes, os 8 pinos de cada porta representam os 8 bits de cada byte e as 8 portas OR adicionais representam os 8 bits de saída de um dos 16 bytes, enquanto que os 4 pinos de cada porta representam as 4 linhas da matriz (Atualmente só são 2 linhas). 

Então galera, vou ficando por aqui com mais uma postagem muito grande, talvez a maior (ou uma das) que eu já fiz, onde esclaresço alguns dos estudos que fiz há pouco tempo e que proporcionou criar estes circuitos, considere-se isto como uma "Prévia de Introdução" de um novo Curso onde ensinarei a criar este circuito no Proteus e reproduzi-lo na vida real utilizando transístores e protoboards para testes (Posteriormente usando placas de cobre e percloreto de ferro para criarmos a PCI depois de pronta), como também quero apresentar alguns fundamentos & componentes básicos da engenharia eletrônica e conceitos de álgebra booleana. É claro que pretendo bater uma meta no Youtube pra realizar este Curso (Vejam nas descrições dos Vídeos) rs Agradeço de coração por quem leu até aqui!! Deixarei aqui 2 vídeos no Youtube simulando e descrevendo estes circuitos no Proteus:

CIRCUITO DE MEMÓRIA RAM DE 16 BYTES:
https://www.youtube.com/watch?v=uvHCrVKdnFc

CIRCUITO LEITOR DE BYTES VIA TEMPORIZAÇÃO:
https://www.youtube.com/watch?v=hy4V2X1Uwjs

#circuitosdigitais #circuitoseletronicos #microprocessador #Microcontroladores #memoriaram